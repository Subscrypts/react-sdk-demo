# Subscrypts React SDK - Claude Instructions

## General Rules
- After finishing a release that is part of a plan, and is commited. Return me a overview of our planned releases and in more details the next release

## Git Commit Rules

**NEVER add Claude references to commits:**
- No `Co-Authored-By: Claude` lines
- No `Generated by Claude` comments
- No AI attribution in commit messages
- Claude must NOT become a contributor to this GitHub repository
- Always ask for permission to commit to github and npm, commits to both platforms are allowed in one task

## Code Style

### TypeScript
- Use TypeScript strict mode
- Prefer explicit types over inference for public APIs
- Use `bigint` for blockchain values (not `number`)
- Use ethers.js v6 patterns and types

### React
- Use functional components with hooks
- Use React Context for state management (no Redux)
- Keep components small and focused
- Custom hooks should start with `use` prefix

### Naming Conventions
- Files: `camelCase.ts` for utilities, `PascalCase.tsx` for components
- Types/Interfaces: `PascalCase` with descriptive suffixes (`Props`, `State`, `Config`)
- Constants: `SCREAMING_SNAKE_CASE`
- Functions: `camelCase`, verbs for actions (`getSubscription`, `createPlan`)

### Error Handling
- Use custom error classes from `src/utils/errors.ts`
- Log errors at appropriate levels (debug for dev, error for failures)
- Always provide meaningful error messages

## Documentation Rules

### CHANGELOG.md
- Update CHANGELOG.md for EVERY version bump
- Use Keep a Changelog format (Added, Changed, Fixed, Removed)
- Include technical details for debugging purposes
- Reference issue numbers when applicable

### Code Comments
- Add JSDoc comments to public APIs (exported functions, types)
- Explain "why" not "what" in inline comments
- Document complex blockchain interactions and contract methods

### README.md
- Only update when public API changes
- Keep examples up to date with current version
- Document breaking changes prominently

### CLAUDE.md
- Update CLAUDE.md when see a pattern or repeative questions that would be effective for almost all prompts during the project
